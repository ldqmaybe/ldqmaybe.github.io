---
layout:     post
title:      重拾系列之——类加载机制
subtitle:   
date:       2021-01-17
author:     dingqiang.l
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - Java
---
## 概述
类加载过程是经过加载、验证、准备、解析和初始化这一系列过程，最终将.class文件加载到内存，形成可以被JVM识别的Java类型。

## 类加载过程
类加载机制从加载开始，到使用，再到释放，需要经过加载、验证、准备、解析、初始化、使用和卸载等几个流程。

> - 加载：将class文件加载到内存，并获取该类的二进制字节流。 
> - 验证：验证文件格式、元数据、字节码和引用符号等。
> - 准备：为类变量（static）分配内存，并初始化（0值），在方法区中分配
> - 解析：将符号引用转化为直接引用
> - 初始化：执行Java程序代码，为类变量真正赋值
> - 使用：各种调用
> - 卸载：应用退出

## 类加载时机
虚拟机规定有且只有5种情况是必须立即对类进行初始化（主动）

#### 主动初始化
 - 遇到new、getstatic、putstatic、invockestatic，分别对应new 对象、读取或设置静态字段（注意是非final修饰的，）、静态方法
 - java.lang.reflect包下的方法反射
 - 初始化类时，父类没有初始化，先初始化父类
 - 启动虚拟机时，指定执行包含main方法的主类，虚拟机会先初始化主类
 - 使用JDK1.7动态语音
#### 主动初始化
 - 子类引用父类静态字段，子类不会被初始化
 - 数组定义引用类，不会触发此类的初始化
 - 静态常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用定义常量的类

创建一个对象经历过程：父类构造器 -> 子类构造器 -> 父类成员变量和实例代码块 -> 父类构造函数 ->  子类成员变量和实例代码块 -> 子类构造函数
## 类加载器
把实现类加载阶段的”通过全限定类名获取此类的二进制字节流“这个动作的代码模块称为类加载器
#### 类加载器种类
 - BootstrapClassLoader根类加载器（启动类加载器）：由C++实现，是JVM的一部分
 - ExtClassLoader扩展类加载器：加载JRE的扩展目录
 - AppClassLoader系统类加载器：加载用户类路径ClassPath上的类库

## 双亲委派模型
子类加载器不会首先去加载类，而是向父类加载器发起请求，一直往上请求，如果父类无法完成加载请求，子类加载器才会自己加载

> 通俗讲就是：儿子很懒，事情都丢给老爸做，老爸做不了了，儿子才自己想办法做

# 最后

附上思维导图一张
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021011623420043.png)

**欢迎关注我的个人微信公众号，【优了个秀】和你每天进步一点点**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191219165723960.jpg#pic_center =200x200)


