---
layout:     post
title:      重拾系列之——JVM垃圾收集机制
subtitle:   
date:       2021-01-16
author:     dingqiang.l
header-img: img/post-bg-digital-native.jpg
catalog: true
tags:
    - Java
---

## 1、概述
对堆内存中已死亡或长时间不使用的对象进行清除和回收，注意是堆，而不是虚拟机栈或常量池。说白了其实就是对谁，在什么时候做了什么不可描述的事。
## 2、判断对象是否可被回收
### 2.1、引用计数法
对象引用一次，计数器+1，引用失效一次，计数器-1，直到计数器为0时，对象可被回收。

> 但是这样有个缺点，就是循环应用的对象无法被回收，比如有A和B两个对象，A持有B的引用，B同样持有A的引用，这样使用该算法计数器是不会为0的

### 2.2、可达性分析算法
通过GC Roots的对象作为根节点往下搜索，当一个对象没有任何引用链相连时，该对象可被回收。可作为GC Roots的对象有

 - 虚拟机栈中的引用对象
 - 方法区中常量和静态属性的引用对象
 - 本地方法区中的引用对象

## 3、垃圾回收算法
### 3.1、标记-清除算法
首先标记可回收对象，再回收被标记可回收的对象。缺点：会产生大量不连续的碎片，效率不高，会遍历所有对象。
### 3.2、复制算法
将内存等比一分为二，每次只在其中的一块内存申请内存；回收时，将存活的对象复制到另一块内存，再将之前的内存清空。这样做的好处是解决了碎片的问题；缺点是内存只有原来的一半
### 3.3、标记整理法
先标记可回收对象，标记过程与"标记-清除"一致的，回收时让所有存活对象向一端移动，然后清除边界以外的内存。该算法优点是解决了碎片和一般可用内存的问题，缺点是频繁移动对象，效率低下。
### 3.4、分代收集算法
该算法解决了内存碎片和效率低下问题。做法是将虚拟机堆中分为新生代和老年代
#### 新生代
每次GC都会有大量对象死亡，少量存活，即朝生夕死。使用的是复制算法，因此回收比较频繁
#### 老年代
大对象，生命周期长，存活率较高（多次回收还存在），使用的是标记清除或标记整理算法。

## 最后

附上一张思维导图

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210116224702626.png)

**欢迎关注我的个人微信公众号，【优了个秀】和你每天进步一点点**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191219165723960.jpg#pic_center =200x200)

